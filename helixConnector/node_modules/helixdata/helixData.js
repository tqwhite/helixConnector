'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	moment = require('moment');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.metaData = {};
	this.addMeta = function(name, data) {
		this.metaData[name] = data;
	}

	// 	qtools.validateProperties({
	// 		subject: args || {},
	// 		targetScope: this, //will add listed items to targetScope
	// 		propList: [
	// 			{
	// 				name: 'placeholder',
	// 				optional: true
	// 			}
	// 		]
	// 	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};


	//LOCAL FUNCTIONS ====================================

	var helixDateTime = function(inDate) {
		//helix example: '6/29/15  8:38:39 AM'

		if (!inDate) {
			return '';
		}

		if (inDate.constructor == Date) {
			var result = moment(inDate).format("MM/DD/YY hh:mm:ss A");
		} else {
			var result = new Date(inDate);
			if (result == "Invalid Date") {
				throw (new Error("Invalid Date string format (helixData.helixDateTime): " + inDate))
			}
		}

		return result;

	}


	var helixBoolean = function(item) {
		if (item === '' || typeof (item) == 'undefined') {
			return '';
		}

		switch (item) {
			case 'true':
			case 'Yes':
				return 'true';
				break;
			case 'false':
			case 'No':
				return 'false';
				break;
			default:
				throw (new Error("no such boolean mapping for " + item + ", says " + moduleFileName));
				break;
		}

	};


	//METHODS AND PROPERTIES ====================================

	self.refId = function() {
		return qtools.newGuid();
	},

	self.helixDateTimeNow = function() {
		return helixDateTime(new Date());
	},

	self.helixDateTime = function(inDate) {
		return helixDateTime(inDate);
	}

	self.helixBoolean = function(inData) {
		return helixBoolean(inData);
	}




	self.makeApplescriptDataString = function(schema, mapping, otherParms, inData) {
		var recordSeparator = ', ';
		switch (qtools.toType(inData)) {

			case 'array':
				var outString = '';
				for (var i = 0, len = inData.length; i < len; i++) {
					var element = inData[i];
					var replaceObject = qtools.extend(element, otherParms);
					outString += '"' + self.stringifyObject(schema, mapping, replaceObject) + '"' + recordSeparator;
				}
				return outString.replace(new RegExp(recordSeparator + '$'), '');
				break;

			case 'object':
				var replaceObject = qtools.extend(inData, otherParms);
				outString = self.stringifyObject(schema, mapping, replaceObject);

				return outString;

				break;
			default:
				throw "inData is of type '" + qtools.toType(inData) + "', not a valid type for conversion to a helix record, ie, object or array";
				break;
		}
	};

	self.stringifyObject = function(schema, mapping, inData) {

		schema = schema || [];

		var outString = '',
			finalFunction;

		for (var i = 0, len = schema.length; i < len; i++) {
			var element = schema[i],
				mappingEntry = mapping[element],
				finalFunction;

			if (typeof (mappingEntry) == 'function') {
				finalFunction = mappingEntry;
			} else if (typeof (mappingEntry) == 'string') {
				if (typeof (self[mappingEntry]) == 'function') {
					finalFunction = self[mappingEntry];
				} else {
					finalFunction = function() {
						return mappingEntry;
					}
				}
			} else {
				finalFunction = function(a) {
					return a
				};
			}

			if (typeof (inData) == 'object' && typeof(inData[element])!='undefined') {
				var result = finalFunction(inData[element]);
			} else {
				var result = '';
			}
			outString += result + String.fromCharCode(9);
		}
		outString = outString.replace(new RegExp(String.fromCharCode(9) + '$'), '');
		return outString;
	};


	self.helixStringToRecordList = function(schema, mapping, resultData) {
		if (!resultData) {
			return resultData;
		}

		resultData = resultData.replace(/\n$/, '');
		var inSchema = [].concat(['helixId'], schema),
			resultDataArray = resultData.split(/record id:/);

		if (!resultDataArray[0]) {
			resultDataArray = resultDataArray.slice(1);
		}

		var outArray = [],
			mappedData,
			fieldName,
			mappingElement,
			incomingValue;
		for (var i = 0, len = resultDataArray.length; i < len; i++) {
			var elementList = resultDataArray[i].replace(/helix record:/, '').replace(/, $/, '').split(/, /),
				newElementObject = {};
			for (var j = 0, len2 = inSchema.length; j < len2; j++) {
				fieldName = inSchema[j];
				mappingElement = mapping[fieldName];
				incomingValue = elementList[j];

				if (typeof (mappingElement) == 'function') {
					mappedData = mappingElement(incomingValue);
				} else if (typeof (self[mappingElement]) == 'function') {
					mappedData = self[mappingElement](incomingValue);
				} else if (typeof (mappingElement) != 'undefined') {
					mappedData = mappingElement;
				} else {
					mappedData = incomingValue;
				}

				newElementObject[inSchema[j]] = mappedData;
			}
			outArray.push(newElementObject);
		}



		return outArray;
	}

	//INITIALIZATION ====================================




	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;







