'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	moment = require('moment');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.metaData = {};
	this.addMeta = function(name, data) {
		this.metaData[name] = data;
	};

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};
	
	//MAPPING HELPERS ====================================

	var helixNumber = function(inData) {
		if (!inData) {
			return '';
		}

		return inData.replace(/[^0-9\.\-]/g, '');
	};

	var helixDateTime = function(inDate) {
		//helix example: '6/29/15  8:38:39 AM'

		if (!inDate) {
			return '';
		}

		if (inDate.constructor == Date) {
			var result = moment(inDate).format('MM/DD/YY hh:mm:ss A');
		} else {
			var result = new Date(inDate);
			if (result == 'Invalid Date') {
				return inDate;
			}
		}

		return result;
	};
	
	var helixBoolean = function(item) {
		if (item === '' || typeof item == 'undefined') {
			return '';
		}
		switch (item) {
			case 'true':
			case 'Yes':
				return 'true';
				break;
			case 'false':
			case 'No':
				return 'false';
				break;
			default:
				return item;
				break;
		}
	};
	
	const helixFilePath = item =>
		item.replace(/^\/Volumes\//, '').replace(/\/+/g, ':');
	
	
	//MAPPING PROPERTIES ====================================
	
	self.booleanToHxString = item => {
		if (item === '' || typeof item == 'undefined') {
			return '';
		}
		return item ? 'Yes' : 'No';
	};
	
	self.stringToNumber = item => {
		if (item === '' || typeof item == 'undefined') {
			return null;
		}
		return +item;
	};
	
	self.stringToBoolean = function(item) {
		if (item === '' || typeof item == 'undefined') {
			return '';
		}

		switch (item.toLowerCase()) {
			case 'true':
			case 'yes':
				return true;
				break;
			case 'false':
			case 'no':
				return false;
				break;
			default:
				qtools.logError(`no boolean mapping for ${item}`);
				return item;
				break;
		}
	};

	self.helixDateTimeNow = function(inData) {
		return helixDateTime(new Date());
	};
	
	self.refId = function(inData) {
		return qtools.newGuid();
	};
	
	self.helixDateTime = function(inDate) {
		return helixDateTime(inDate);
	};
	
	self.helixNumber = function(inData) {
		return helixNumber(inData);
	};
	
	self.helixBoolean = function(inData) {
		return helixBoolean(inData);
	};
	
	self.helixFilePath = function(inData) {
		return helixFilePath(inData);
	};
	
	self.toUpperCase = function(inData) {
		return inData.toString().toUpperCase();
	};
	
	self.passThrough = function(inData) {
		return inData;
	};
	
	self.mysqlTimeStamp = function(inData) {
		return moment(Date.now()).format('YYYY-MM-DD HH:mm:ss');
	};
	
	self.toHelixDateTime = function(inDate) {
		//helix example: '6/29/15  8:38:39 AM'

		if (!inDate) {
			return '';
		}

		if (inDate.constructor == Date) {
			var result = moment(inDate).format('MM/DD/YY hh:mm:ss A');
		} else {
			var result = moment(new Date(inDate)).format('MM/DD/YY hh:mm:ss A');
			if (result == 'Invalid Date') {
				return inDate;
			}
		}

		return result;
	};
	
	
	self.BooleanType = (value, destination) => {
		if (typeof value == 'undefined' || value === '') {
			return;
		}
		switch (destination) {
			case 'toHelix':
				return value ? 'Yes' : 'No';
				break;
			case 'toJson':
				if (!value) {
					return false;
				}
				switch (value.toString().toLowerCase()) {
					case 'true':
					case 'yes':
					case '1':
						return true;
					case 'false':
					case 'no':
					case '0':
						return false;
					default:
						qtools.logError(`${value} is not a valid boolean value`);
						return value;
						break;
				}
				break;
		}
	};

	self.DateTimeType = (value, destination) => {
		if (typeof value == 'undefined' || value === '') {
			return;
		}
		const result = new Date(value);

		if (result == 'Invalid Date') {
			const message = `String '${value}' cannot be parsed into date (helixData.DateTimeType)`;
			qtools.logError(message);
			return value;
		}
		switch (destination) {
			case 'toHelix':
				//helix example: '6/29/15  8:38:39 AM'
				return moment(result).format('MM/DD/YY hh:mm:ss A');
				break;
			case 'toJson':
				return result.toUTCString();
				break;
		}
	};

	self.NumberType = (value, destination) => {
		if (typeof value == 'undefined' || value === '') {
			return '';
		}
		if (typeof +value != 'number') {
			return value;
		}

		switch (destination) {
			case 'toHelix':
				return value;
				break;
			case 'toJson':
				return +value;
				break;
		}
	};

	self.StringType = (value, destination) => {
		if (typeof value == 'undefined') {
			return;
		}
		switch (destination) {
			case 'toHelix':
				return value.toString();
				break;
			case 'toJson':
				return value.toString();
				break;
		}
	};

	self.TimeStampType = (value, destination) => {
		const timeStamp = value ? value : new Date();
		return self.DateTimeType(timeStamp, destination);
	};

	self.UuidStampType = (value, destination) => {
		const tmp = value ? value : qtools.newGuid();
		return tmp;
	};

	
	//SYSTEM DATA MANIPULATION ====================================
	
	//this is called as compileScript()
	self.makeApplescriptDataString = function(
		schema,
		mapping,
		otherParms,
		inData,
		separators
	) {
		const destination = 'toHelix';
		separators = separators ? separators : {};
		var recordSeparator = separators.record ? separators.record : ', ';
		const fieldSeparator = separators.field
			? separators.field
			: String.fromCharCode(9);
		switch (qtools.toType(inData)) {
			case 'array':
				var outString = '';
				for (var i = 0, len = inData.length; i < len; i++) {
					var element = inData[i];
					var replaceObject = qtools.extend(element, otherParms);
					outString +=
						'"' +
						self.stringifyObject(
							schema,
							mapping,
							replaceObject,
							fieldSeparator,
							destination
						) +
						'"' +
						recordSeparator;
				}
				return outString.replace(new RegExp(recordSeparator + '$'), '');
				break;

			case 'object':
				var replaceObject = qtools.extend(inData, otherParms);
				outString = self.stringifyObject(
					schema,
					mapping,
					replaceObject,
					fieldSeparator,
					destination
				);

				return outString;

				break;

			default:
				qtools.logError(
					`inData '${inData}' is of type '${qtools.toType(
						inData
					)}', not a valid type for conversion to a helix record, ie, object or array`
				);
				return `inData '${inData}' is of type '${qtools.toType(
					inData
				)}', not a valid type for conversion to a helix record, ie, object or array`;
				break;
		}
	};

	self.stringifyObject = function(
		schema,
		mapping,
		inData,
		fieldSeparator = '\t',
		destination
	) {
		schema = schema || [];

		var outString = '',
			finalFunction;

		for (var i = 0, len = schema.length; i < len; i++) {
			var element = schema[i],
				mappingEntry = mapping[element],
				finalFunction;
			if (typeof mappingEntry == 'function') {
				finalFunction = mappingEntry;
			} else if (typeof mappingEntry == 'string') {
				if (typeof self[mappingEntry] == 'function') {
					finalFunction = self[mappingEntry];
				} else {
					finalFunction = function() {
						return mappingEntry;
					};
				}
			} else {
				finalFunction = function(a) {
					return a;
				};
			}

			if (typeof inData == 'object' && typeof inData[element] != 'undefined') {
				var result = finalFunction(inData[element], destination);
			} else {
				var result = '';
			}
			outString += result + fieldSeparator;
		}
		outString = outString.replace(new RegExp(String.fromCharCode(9) + '$'), '');
		
		return outString;
	};

	self.helixStringToRecordList = function(schema, rawHelixData) {
		const destination = 'toJson';
		if (!rawHelixData) {
			return rawHelixData;
		}
		const { fieldSequenceList, mapping } = schema;
		const separators = schema.separators ? schema.separators : {};
		const fieldSeparator = separators.field ? separators.field : '\t';
		const recordSeparator = separators.record ? separators.record : '\n';
		const inSchema = [].concat(['helixId'], fieldSequenceList);
		let debugInfo='';

		debugInfo+=qtools.dump(({
				[`${schema.schemaName}.fieldList [helixData.helixStringToRecordList]`]: inSchema
			}), true);

		var recordStringList = rawHelixData
			.replace(new RegExp(`${recordSeparator}+$`, 'g'), '')
			.replace(/record id:(\d+), /g, '$1' + fieldSeparator)
			.replace(/helix record:/g, '')
			.split(new RegExp(recordSeparator));

		if (!recordStringList[0]) {
			recordStringList = recordStringList.slice(1);
		}

		const recordObjectList = recordStringList.map(item =>
			item
				.replace(new RegExp(`${fieldSeparator}$`), '')
				.split(new RegExp(`${fieldSeparator}`))
		);

		debugInfo+=recordObjectList.reduce((debugString, item)=>{
			return `${debugString}\n${item.join('| ').replace(/| $/, '')}`;
		},`\n${schema.schemaName} RECORD OBJECT LIST:\n`)+"\n\n:";

		let outArray = [];
		let mappedData;
		let fieldName;
		let mappingElement;
		let incomingValue;
		debugInfo+=`\n${schema.schemaName} PROCESSING VALUES:\n`;
		for (var i = 0, len = recordObjectList.length; i < len; i++) {
			var elementList = recordObjectList[i];

			var newRecordObject = {};
			for (var j = 0, len2 = inSchema.length; j < len2; j++) {
				fieldName = inSchema[j];
				mappingElement = mapping[fieldName];
				incomingValue = elementList[j];

				if (typeof mappingElement == 'function') {
					debugInfo+=`\n${fieldName}, ${mappingElement}, ${incomingValue}, ${destination} (???)`;
					mappedData = mappingElement(incomingValue, destination);
				} else if (typeof self[mappingElement] == 'function') {
					debugInfo+=`\n${fieldName}, ${mappingElement}, ${incomingValue}, ${destination} (mapping data type found)`;
					mappedData = self[mappingElement](incomingValue, destination);
				} else if (typeof mappingElement != 'undefined') {
					mappedData = mappingElement;
					debugInfo+=`\n${fieldName}, ${mappingElement}, ${incomingValue}, ${destination} (mapping constant)`;
				} else {
					debugInfo+=`\nX:${fieldName}, default(StringType), ${incomingValue}, ${destination} (no mapping specified)`;
					mappedData = self.StringType(incomingValue, destination);
				}

				newRecordObject[fieldName] = mappedData;
			}
			outArray.push(newRecordObject);
			debugInfo+="\n"
		}
		if (schema.debugData=='true'){
			qtools.logDebug(debugInfo+`${schema.schemaName} end\n`);
		}
		return outArray;
	};
	
	self.arrayOfRecordsToArrayOfResponseObjects = (
		fieldSequenceList,
		mapping = {},
		data
	) => {
		const destination = 'toJson';
		const outArray = [];
		for (let i = 0, len = data.length; i < len; i++) {
			const recordObject = {};
			const dataArray = data[i];
			for (let j = 0, len2 = dataArray.length; j < len2; j++) {
				const elementName = fieldSequenceList[j];
				recordObject[elementName] = mapping[elementName]
					? self[mapping[elementName]](dataArray[j], destination)
					: dataArray[j];
			}
			outArray.push(recordObject);
		}
		return outArray;
	};
	
	self.remoteControlConversionList = {};
	self.remoteControlConversionList.stringToJson = (
		conversionArgs,
		result,
		callback
	) => {
		const recordSep = conversionArgs.parameters.recordSep || '\n';
		const fieldSep = conversionArgs.parameters.fieldSep || '\t';
		const outData = result
			.split(recordSep)
			.map(item => item.split(fieldSep))
			.filter(item => item.join());
		callback('', outData);
	};
	self.remoteControlConversionList.cleanToJson = (
		conversionArgs,
		result,
		callback
	) => {
		if (!result) {
			callback('', {
				error: `data source provide no result (${typeof result}).`
			});
			return;
		}

		let outData;
		const cleanString = result
			.replace(/^\"/, '')
			.replace(/(]|})[^\}\]]*$/, '$1')
			.replace(/\\/g, '');
		try {
			outData = JSON.parse(cleanString);
		} catch (e) {
			callback('', e);
			return;
		}

		callback('', outData);
	};

	//INITIALIZATION ====================================
	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;

