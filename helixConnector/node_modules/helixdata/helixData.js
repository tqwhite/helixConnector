'use strict';
var qtools = require('qtools'),
	qtools = new qtools(module),
	events = require('events'),
	util = require('util'),
	moment = require('moment');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	events.EventEmitter.call(this);
	this.forceEvent = forceEvent;
	this.args = args;
	this.metaData = {};
	this.addMeta = function(name, data) {
		this.metaData[name] = data;
	};

	// 	qtools.validateProperties({
	// 		subject: args || {},
	// 		targetScope: this, //will add listed items to targetScope
	// 		propList: [
	// 			{
	// 				name: 'placeholder',
	// 				optional: true
	// 			}
	// 		]
	// 	});

	var self = this,
		forceEvent = function(eventName, outData) {
			this.emit(eventName, {
				eventName: eventName,
				data: outData
			});
		};
	
	//LOCAL FUNCTIONS ====================================

	var helixNumber = function(inData) {
		if (!inData) {
			return '';
		}

		return inData.replace(/[^0-9\.\-]/g, '');
	};

	var helixDateTime = function(inDate) {
		//helix example: '6/29/15  8:38:39 AM'

		if (!inDate) {
			return '';
		}

		if (inDate.constructor == Date) {
			var result = moment(inDate).format('MM/DD/YY hh:mm:ss A');
		} else {
			var result = new Date(inDate);
			if (result == 'Invalid Date') {
				throw new Error(
					'Invalid Date string format (helixData.helixDateTime): ' + inDate
				);
			}
		}

		return result;
	};
	
	var helixBoolean = function(item) {
		if (item === '' || typeof item == 'undefined') {
			return '';
		}
		switch (item) {
			case 'true':
			case 'Yes':
				return 'true';
				break;
			case 'false':
			case 'No':
				return 'false';
				break;
			default:
				throw new Error(
					'no such boolean mapping for ' +
						item +
						', says ' +
						qtools.employerFilename
				);
				break;
		}
	};
	
	const helixFilePath = item =>
		item.replace(/^\/Volumes\//, '').replace(/\/+/g, ':');
	
	//METHODS AND PROPERTIES ====================================

	(self.refId = function() {
		return qtools.newGuid();
	}),
		(self.helixDateTimeNow = function() {
			return helixDateTime(new Date());
		}),
		(self.helixDateTime = function(inDate) {
			return helixDateTime(inDate);
		}),
		(self.helixNumber = function(inData) {
			return helixNumber(inData);
		});

	self.helixBoolean = function(inData) {
		return helixBoolean(inData);
	};
	
	self.helixFilePath = function(inData) {
		return helixFilePath(inData);
	};
	
	self.makeApplescriptDataString = function(
		schema,
		mapping,
		otherParms,
		inData,
		separators
	) {
		separators=separators?separators:{};
		var recordSeparator = separators.record?separators.record:', ';
		const fieldSeparator=separators.field?separators.field:String.fromCharCode(9);
		switch (qtools.toType(inData)) {
			case 'array':
				var outString = '';
				for (var i = 0, len = inData.length; i < len; i++) {
					var element = inData[i];
					var replaceObject = qtools.extend(element, otherParms);
					outString +=
						'"' +
						self.stringifyObject(schema, mapping, replaceObject, fieldSeparator) +
						'"' +
						recordSeparator;
				}
				return outString.replace(new RegExp(recordSeparator + '$'), '');
				break;

			case 'object':
				var replaceObject = qtools.extend(inData, otherParms);
				outString = self.stringifyObject(schema, mapping, replaceObject, fieldSeparator);

				return outString;

				break;
			default:
				throw "inData is of type '" +
					qtools.toType(inData) +
					"', not a valid type for conversion to a helix record, ie, object or array";
				break;
		}
	};

	self.stringifyObject = function(schema, mapping, inData, fieldSeparator='\t') {
		schema = schema || [];

		var outString = '',
			finalFunction;

		for (var i = 0, len = schema.length; i < len; i++) {
			var element = schema[i],
				mappingEntry = mapping[element],
				finalFunction;

			if (typeof mappingEntry == 'function') {
				finalFunction = mappingEntry;
			} else if (typeof mappingEntry == 'string') {
				if (typeof self[mappingEntry] == 'function') {
					finalFunction = self[mappingEntry];
				} else {
					finalFunction = function() {
						return mappingEntry;
					};
				}
			} else {
				finalFunction = function(a) {
					return a;
				};
			}

			if (typeof inData == 'object' && typeof inData[element] != 'undefined') {
				var result = finalFunction(inData[element]);
			} else {
				var result = '';
			}
			outString += result + fieldSeparator;
		}
		outString = outString.replace(new RegExp(String.fromCharCode(9) + '$'), '');
		return outString;
	};

	self.helixStringToRecordList = function(schema, resultData) {
		if (!resultData) {
			return resultData;
		}
		const { fieldSequenceList, mapping } = schema;
		const separators = schema.separators ? schema.separators : {};
		const fieldSeparator = separators.field ? separators.field : '\t';
		const recordSeparator = separators.record ? separators.record : '\n';

		resultData = resultData
			.replace(new RegExp(`${recordSeparator}+$`, 'g'), '')
			.replace(/record id:(\d+), /g, '$1' + fieldSeparator)
			.replace(/helix record:/g, '');
		var inSchema = [].concat(['helixId'], fieldSequenceList),
			resultDataArray = resultData.split(new RegExp(recordSeparator));
		if (!resultDataArray[0]) {
			resultDataArray = resultDataArray.slice(1);
		}
		var outArray = [],
			mappedData,
			fieldName,
			mappingElement,
			incomingValue;


		for (var i = 0, len = resultDataArray.length; i < len; i++) {
			var elementList = resultDataArray[i]
				.replace(new RegExp(`${fieldSeparator}$`), '')
				.split(new RegExp(`${fieldSeparator}`));

			var newElementObject = {};
			for (var j = 0, len2 = inSchema.length; j < len2; j++) {
				fieldName = inSchema[j];
				mappingElement = mapping[fieldName];
				incomingValue = elementList[j];

				if (typeof mappingElement == 'function') {
					mappedData = mappingElement(incomingValue);
				} else if (typeof self[mappingElement] == 'function') {
					mappedData = self[mappingElement](incomingValue);
				} else if (typeof mappingElement != 'undefined') {
					mappedData = mappingElement;
				} else {
					mappedData = incomingValue;
				}

				newElementObject[inSchema[j]] = mappedData;
			}
			outArray.push(newElementObject);
		}

		return outArray;
	};
	
	self.arrayOfRecordsToArrayOfResponseObjects = (fieldSequenceList, mapping={}, data) => {
		
		const outArray = [];
		for (let i = 0, len = data.length; i < len; i++) {
			const recordObject = {};
			const dataArray = data[i];
			for (let j = 0, len2 = dataArray.length; j < len2; j++) {
				const elementName=fieldSequenceList[j];
				recordObject[elementName] = (mapping[elementName])?self[mapping[elementName]](dataArray[j]):dataArray[j];
			}
			outArray.push(recordObject);
		}
		return outArray;
	};
	
	
	
	
	
	
	
	self.booleanToHxString=item=>{
		if (item === '' || typeof item == 'undefined') {
			return '';
		}
		return item?'Yes':'No';
	
	}
	
	
	self.stringToNumber=item=>{
		if (item === '' || typeof item == 'undefined') {
			return '';
		}
		return +item;
	
	}
	
	self.stringToBoolean = function(item) {
		if (item === '' || typeof item == 'undefined') {
			return '';
		}
		switch (item.toLowerCase()) {
			case 'true':
			case 'yes':
				return true;
				break;
			case 'false':
			case 'no':
				return false;
				break;
			default:
				qtools.log(`WARNING: no such boolean mapping for ${item}, says ${stringToBoolean}/${stringToBoolean}`);
				throw new Error(`no such boolean mapping for ${item}, says ${stringToBoolean}/${stringToBoolean}`);
				break;
		}
	};
	
	
	
	
	

	//INITIALIZATION ====================================
	return this;
};

//END OF moduleFunction() ============================================================

util.inherits(moduleFunction, events.EventEmitter);
module.exports = moduleFunction;

